[["index.html", "Theory Club Notes Prerequisites What is this document for? How these web pages were created?", " Theory Club Notes McCann Lab 2020-12-15 Prerequisites What is this document for? A notebook to put notes for our Theory Club. How these web pages were created? A notebook to put notes for our Theory Club. This book was generated using bookdown (Xie 2015) (see https://github.com/rstudio/bookdown-demo for a minimal example). References "],["intro.html", "Chapter 1 Introduction 1.1 Theory in ecology", " Chapter 1 Introduction 1.1 Theory in ecology "],["dynamical-systems-theory-getting-started.html", "Chapter 2 Dynamical Systems Theory – Getting Started", " Chapter 2 Dynamical Systems Theory – Getting Started Here is a brief overview of some important steps to follow when starting with any new system of equations. Our computers can do these steps easily, and you now have code to do this, but it’s good to practice these by hand for simple systems (one- and two-dimensions) to help your understanding of these models. I (Carling Bieg) have underlined important terms throughout this document, and made a list below so that you can review them and begin making your own definition table. This is by no means an exhaustive list of important terms for dynamical systems theory, but is important for these steps described below. We will add to this as we go on. Start with the equation(s) describing a system – these describe the rate of change over time, t, in density of our state variable(s), or population(s). Let’s say we have one resource population; we can call this equation \\(f_R\\). Set \\(f_R\\) to 0 and solve for R. This tells us when the rate of change is 0, and therefore the population is at an equilibrium. Often we refer to these solutions as \\(\\mathbb{R}^\\ast\\). Note that with multiple state variables (e.g., a C-R model), our solutions will lead to functions (e.g., lines, curves) that depend on the other state variable(s) rather than just fixed points. These are what we call zero-growth isoclines, also referred to as nullclines. Our equilibria (\\(C^\\ast\\), \\(R^\\ast\\)) are where these clines intersect, such that the rate of change each state variable is 0. At this point it can be useful to plot these equilibrium solutions in state space. In a one-dimensional case, we can visualize our solutions on a line (one dimension), and in multiple dimensions we plot our clines as functions of our state variables in this space (e.g., solutions of C as a function of R for a two-dimensional C-R model). One we have our solutions plotted, we can immediately see how each of the parameters in our model affect the equilibria and begin to visualize where we may see bifurcations. It is also useful to plot trajectories or vector fields on each of these clines and around our equilibria. Keep in mind that trajectories will only point in one dimension directly on the clines, so note that the geometry of the isoclines importantly affects the dynamics. Visually piecing together the entire phase space immediately tells us a lot about stability before we even move on to the next steps! Next we want to linearize the system by taking the partial derivatives of our equations with respect to each of the state variables. Note that in a one-dimensional system (e.g., \\(f_R\\)), we just need to take the derivative (i.e., $). We put this in matrix form such that for every dimension, n, of our system we get an n x n matrix, which we call the Jacobian matrix. For a two-dimensional system (e.g., \\(f_R\\) and \\(f_C\\)), this will be in the form: \\[\\begin{pmatrix} \\frac{\\partial f_R}{\\partial R} &amp; \\frac{\\partial f_R}{\\partial C} \\\\ \\frac{\\partial f_C}{\\partial R} &amp; \\frac{\\partial f_C}{\\partial C} \\\\ \\end{pmatrix}\\] Once we have solved for our derivatives, we can substitute in our equilibrium solutions. We can do this for each of our equilibria. (Remember we always have trivial equilibria that still matter!) This results in a linearization of our model around the equilibria. Now we can calculate our eigenvalues. In our one-dimensional case, the work is done for us. Our eigenvalue is simply equal to our derivative (technically this is a 1 x 1 matrix). For multiple dimensions we need to do a bit of matrix algebra to diagonalize our matrix, which effectively transforms our matrix to a form that separates the dimensions of our eigenvalues. This transformation is as follows... Every matrix, A, has eigenvalues, λ, and eigenvectors, v, such that Av = λv This can be re-written as follows: Av – λv = 0 Av – λIv = 0 (A – λI)v = 0 Note here that I is an n x n identity matrix, so λI is a n x n diagonal matrix with λ1 ... λn on the diagonals. (A – λI) is our diagonalized matrix. Finally, as long as v is non-zero, then this will only have a solution if: |A – λI| = 0 This equation is referred to as the characteristic equation of A and is an nth order polynomial in λ with n distinct (but not necessarily unique) roots. Using the characteristic equation of our Jacobian matrix, we can now solve for our eigenvalues associated with each equilibrium. To do this, we take the determinant of our (A- λI) matrix. Note that this diagonalization has simply transformed this to be our Jacobian matrix with λ subtracted in the diagonals, but it is good to know where this transformation comes from. Finally we can now use simple algebra to solve the resulting polynomial for λ. HINT: For a 2 x 2 matrix, A, of the form A = \\(\\begin{pmatrix} a &amp; b \\\\ c &amp; d \\\\ \\end{pmatrix}\\) The determinant, det(A) or |A|, is equal to (ad) - (bc). In this case, the determinant gives us a quadratic equation, which we can solve using the quadratic formula: If a quadratic equation has the form: x λ2 + y λ + z = 0 Then λ = \\(\\frac{- y\\ \\pm \\ \\sqrt{}(y^{2} - 4xz)}{2x}\\) Note that for more information, any linear algebra textbook should explain eigenvalues and eigenvectors (and how to solve for them, including matrix transformations and diagonalization) in more detail. "],["introduction-to-lotka-volterra-competition-with-r.html", "Chapter 3 Introduction to Lotka-Volterra Competition with R 3.1 Solving Differential Equations with R 3.2 Model and Parameters 3.3 Evaluating the model – time series 3.4 Equilibria and Isoclines 3.5 Now plot the isoclines", " Chapter 3 Introduction to Lotka-Volterra Competition with R 3.1 Solving Differential Equations with R There are several solvers of differential equation R packages, among those: deSolve; odeintr; odein; diffeqr an interface to the ‘DifferentialEquations.jl’ Julia package. Below, we will be using odein : library(odin) 3.2 Model and Parameters The model we will use is the classical Lotka-Voltera competition model: \\[ \\left\\{ \\begin{array}{l} \\dot{R_1} = r_1R_1*(1 - \\frac{R_1+\\alpha_{12}R_2}{K1})rR - aCR \\\\ \\dot{R_2} = r_2R_2*(1 - \\frac{R_2+\\alpha_{21}R_1}{K2})eaCR - mC \\end{array} \\right. \\] Using odin, here is what to do to create the model lv_comp &lt;- odin({ ## Derivatives deriv(y1) &lt;- y1 * r1 * (1 - (y1 + alpha12 * y2) / K1) deriv(y2) &lt;- y2 * r2 * (1 - (y2 + alpha21 * y1) / K2) ## Initial conditions initial(y1) &lt;- .5 initial(y2) &lt;- .5 ## parameters alpha12 &lt;- 0.8 alpha21 &lt;- 0.3 r1 &lt;- 1.0 r2 &lt;- 2.0 K1 &lt;- 1.5 K2 &lt;- 1.0 }) #&gt; gcc -I&quot;/usr/local/lib/R/include&quot; -DNDEBUG -I/usr/local/include -fpic -g -O2 -fstack-protector-strong -Wformat -Werror=format-security -Wdate-time -D_FORTIFY_SOURCE=2 -g -c odin_52f4d32e.c -o odin_52f4d32e.o #&gt; gcc -shared -L/usr/local/lib/R/lib -L/usr/local/lib -o odin_52f4d32e.so odin_52f4d32e.o -L/usr/local/lib/R/lib -lR Then lv_comp() creates a solver for the problem described below: mod &lt;- lv_comp() mod #&gt; &lt;odin_model&gt; #&gt; Public: #&gt; contents: function () #&gt; deriv: function (t, y) #&gt; initial: function (t) #&gt; initialize: function (user = NULL, unused_user_action = NULL, use_dde = FALSE) #&gt; ir: {&quot;version&quot;:&quot;1.0.8&quot;,&quot;config&quot;:{&quot;base&quot;:&quot;odin&quot;,&quot;include&quot;:[]} ... #&gt; run: function (t, y = NULL, ..., use_names = TRUE, tcrit = NULL) #&gt; set_user: function (..., user = list(...), unused_user_action = NULL) #&gt; transform_variables: function (y) #&gt; Private: #&gt; core: list #&gt; discrete: FALSE #&gt; dll: odin_52f4d32e #&gt; init: 0.5 0.5 #&gt; interpolate_t: NULL #&gt; n_out: 0 #&gt; name: odin #&gt; output_order: NULL #&gt; ptr: externalptr #&gt; update_metadata: function () #&gt; use_dde: FALSE #&gt; user: #&gt; variable_order: list #&gt; ynames: t y1 y2 3.3 Evaluating the model – time series Then, to solve the problem, one must create a sequence of values and used the run function of the solver: # Sequence of time values t &lt;- seq(0, 100, by = 1e-4) y &lt;- mod$run(t) Let’s do a quick plot # few tweaks par(mar = c(4.1, 5.1, 0.5, 0.5), las = 1) # colors pal &lt;- c(&quot;#009afa&quot;, &quot;#e99172&quot;) matplot(y[, 1], y[, -1], xlab = &quot;Time&quot;, ylab = &quot;Abundance&quot;, type = &quot;l&quot;, col = pal, lty = 1, lwd = 3) legend(&quot;bottomright&quot;, c(&quot;R1&quot;, &quot;R2&quot;), col = pal, lwd = 3, bty = &quot;n&quot;, cex = 1.5) 3.4 Equilibria and Isoclines Skipped! Note that there are ways of obtaining Jacobian in R (see JacobianCpp() in odeintr and the function D() in the package stats that should already be installed), but overall I (Kevin Cazelles) would say that R is not really well-equipped for such tasks and I would use Julia or SageMath rather than R to do symbolic computation (at large). 3.5 Now plot the isoclines We will again use the manipulate function to see how our parameters change the isoclines. This can immediately tell us a lot about our equilibria and stability. draw_isocline &lt;- function(mod, pal) { pr &lt;- mod$contents() abline(a = pr$K1, b = -pr$alpha12, col = pal[1]) abline(a = pr$K2/pr$alpha21, b = -1/pr$alpha21, col = pal[2]) } Then let’s do the final plot: R1 = c(0, 3) R2 = c(0, 5) plot(R1, R2, type = &quot;n&quot;) draw_isocline(mod, pal) # points(.5, .5, pch = 19, cex = 2) text(.5, .5, &quot;1&quot;, pos = 3) lines(y[,3], y[,2], type = &quot;l&quot;, lwd = 3) # with a different starting point y2 &lt;- mod$run(t, y = c(4, 2)) points(2, 4, pch = 19, cex = 2, col = &quot;grey40&quot;) text(2, 4, &quot;2&quot;, col = &quot;grey40&quot;, pos = 3) lines(y2[,3], y2[,2], type = &quot;l&quot;, lwd = 3, col = &quot;grey40&quot;) "],["definitions.html", "Chapter 4 Definitions", " Chapter 4 Definitions State variable: Parameter: Equilibrium: Trivial equilibrium: Isocline: Nullcline: State space: Phase space: Trajectory: Vector field: Bifurcation: Jacobian matrix: Linearization: Eigenvalue: Eigenvector: Diagonalization: Characteristic equation: Polynomial: Determinant: Quadratic equation: Quadratic formula: "],["resource.html", "Chapter 5 Resources 5.1 Books 5.2 Websites 5.3 Videos", " Chapter 5 Resources 5.1 Books 5.2 Websites 5.3 Videos Chaos a Mathematical Adventure https://www.chaos-math.org/en.html Essence of linear algebra preview https://www.youtube.com/watch?v=kjBOesZCoqc&amp;list=PLZHQObOWTQDPD3MizzM2xVFitgF8hE_ab "]]
